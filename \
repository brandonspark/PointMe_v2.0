#load "str.cma";;

type token =
   | Identifier of string 
   | StrLit of string
   | ChrLit of char
   | Const of int
   | LParen
   | RParen
   | LBrace
   | RBrace
   | LBracket
   | RBracket
   | Plus
   | Minus
   | Asterisk
   | Arrow
   | Equal of token option
   | Decrement
   | Increment
   | Slash
   | Bang
   | Tilde
   | Percent
   | RChevron
   | RShift
   | LChevron
   | LShift
   | Amper
   | Caret
   | Pipe
   | And
   | Or
   | QMark
   | Colon
   | Comma
   | Semicolon
   | Period
   | EqEq
   | Leq
   | Geq


module Lexer =
struct
    let rec programToString (fileName : string) : string =
        let input = open_in fileName in
        let s = really_input_string input (in_channel_length input) in
        close_in input; s

    let explode (s : string) : char list = List.init (String.length s) (String.get s)

    let tokens = ['('; ')'; '{'; '}'; '['; ']'; ',';     (* separators *)
                  '~'; '.'; ';'; '?'; ':']

    let tokens2 = ['*'; '/'; '!'; '%'; '='; '^'] (* standalone + = after *)
   
    let rec checkFirst (first : char) (rest : char list) (ref : char list) (acc : char list) =
        match rest with
            [] -> (rest, ' '::first::' '::acc)
          | second::xs -> if List.mem second ref then (xs, ' '::second::first::' '::acc)
                                       else (rest, ' '::first::' '::acc)
    
    let minusList = ['>'; '-'; '=']
    let plusList = ['+'; '=']
    let ampList = ['&'; '=']
    let pipeList = ['|'; '=']

    let rec spaceOut (cs : char list) (acc : char list) (quoteMark : bool) : char list =
        if quoteMark then
        (match cs with
            '"'::xs -> spaceOut xs ('"'::acc) (not quoteMark)
          | x::xs -> spaceOut xs (x::acc) quoteMark)
        else
        (match cs with
            [] -> acc
          | '"'::xs -> spaceOut xs ('"'::acc) (not quoteMark)
          | '\t'::xs -> spaceOut xs (' '::acc) quoteMark
          | '\n'::xs -> spaceOut xs (' '::acc) quoteMark
          | '-'::xs -> let (rest, acc') = checkFirst '-' xs minusList acc in
                       spaceOut rest acc' quoteMark
          | '+'::xs -> let (rest, acc') = checkFirst '+' xs plusList acc in
                       spaceOut rest acc' quoteMark
          | '&'::xs -> let (rest, acc') = checkFirst '&' xs ampList acc in
                       spaceOut rest acc' quoteMark
          | '|'::xs -> let (rest, acc') = checkFirst '|' xs pipeList acc in
                       spaceOut rest acc' quoteMark
          | '>'::xs -> (match xs with 
                       | '='::xs' -> spaceOut xs' (' '::'='::'>'::' '::acc) quoteMark
                       | '>'::'='::xs' -> spaceOut xs' (' '::'='::'>'::'>'::' '::acc) quoteMark
                       | '>'::xs' -> spaceOut xs' (' '::'>'::'>'::' '::acc) quoteMark
                       | _ -> spaceOut xs (' '::'>'::' '::acc) quoteMark)
          | '<'::xs -> (match xs with
                       | '='::xs' -> spaceOut xs' (' '::'='::'<'::' '::acc) quoteMark
                       | '<'::'='::xs' -> spaceOut xs' (' '::'='::'<'::'<'::' '::acc) quoteMark
                       | '<'::xs' -> spaceOut xs' (' '::'<'::'<'::' '::acc) quoteMark
                       | _ -> spaceOut xs (' '::'<'::' '::acc) quoteMark)
          | x::xs -> if List.mem x tokens then spaceOut xs (' '::x::' '::acc) quoteMark
                else if List.mem x tokens2 then 
                     let (rest, acc') = checkFirst x xs ['='] acc in
                        spaceOut rest acc' quoteMark
                      else spaceOut xs (x::acc) quoteMark)
    
    let rec removeDupes (cs : char list) (acc : char list) : char list =
        match cs with
            [] -> acc
          | ' '::[] -> acc
          | ' '::' '::xs -> removeDupes (' '::xs) acc
          | x::xs -> removeDupes xs (x::acc)

    let split (fileName : string) : string list =
        let programString = programToString fileName in
        let spaced = spaceOut (explode programString) [] false in
        let noDupes = removeDupes spaced [] in
        let buf = Buffer.create (List.length noDupes) in
        let () = List.iter (Buffer.add_char buf) noDupes in
        (*let final = *)String.split_on_char ' ' (Buffer.contents buf) 
        (*List.filter (fun s -> s <> "") final*)

    exception NoMatch

    let regexDec = Str.regexp "0\\|[1-9][0-9]*"
    let regexHex = Str.regexp "0[xX][0-9a-fA-F]+"

    let regexId = Str.regexp "[A-Za-z_][A-Za-z0-9_]*"
    (*let regexStrLit = Str.regexp "\"[-~\|\\n\|\\t\|\\v\|\\b\|\\r\|\\f\|\\a\|\\\\\|\\'\|\\\"]*\""
    let regexCharLit = Str.regexp ""*)

    let regex_nchar = Str.regexp "[ -~]"

    let matchFull (r : Str.regexp) (s : string) =
        let m = Str.search_forward r s 0 in
        match m with
            0 -> true
          | _ -> false

    let hasLast (rest : char list) (c : char) = match rest with
        [] -> false
      | _ -> List.nth rest (List.length rest - 1) = c

    let is_esc = function
        '\n' | '\t' | '\b' | '\r' | '\\' | '\'' | '"' -> true
      | _ -> false

    let is_printable (c: char) =
        if Char.code c >= 32 && Char.code c <= 126 then true
                                         else false

    let str_pred (p : char -> bool) (s : string) = 
        let seq = String.to_seq s in
        Seq.fold_left (fun acc c -> acc && (p c)) true seq

    let matchRest (cs : char list) : token = match cs with
        [] -> raise NoMatch
      | '"'::rest -> if hasLast rest '"' then 
                        raise NoMatch
                    else raise NoMatch
      | '\''::rest -> if hasLast rest '\'' then
                        if List.length rest = 2 && is_printable (List.nth rest 0) then
                            ChrLit (List.nth rest 0)
                        else (match rest with
                            ['\\'; 'n'] -> raise NoMatch
                          | ['\\'] -> raise NoMatch)
                      else raise NoMatch
      | '<'::rest -> raise NoMatch
      | ('0'::'x'::rest | '0'::'X'::rest) -> raise NoMatch
      

    let matcher (s : string) : token = match s with
        "(" -> LParen
      | ")" -> RParen 
      | ";" -> Semicolon
      | "." -> Period
      | "," -> Comma
      | "[" -> LBracket
      | "]" -> RBracket
      | "-" -> Minus
      | "--" -> Decrement
      | "->" -> Arrow
      | "-=" -> Equal (Some Minus)
      | "*" -> Asterisk
      | "*=" -> Equal (Some Asterisk)
      | "+" -> Plus
      | "++" -> Increment
      | "+=" -> Equal (Some Plus)
      | "/" -> Slash
      | "/=" -> Equal (Some Slash)
      | "!" -> Bang
      | "!=" -> Equal (Some Bang)
      | "~" -> Tilde
      | "%" -> Percent
      | "%=" -> Equal (Some Percent)
      | ">" -> RChevron
      | ">=" -> Geq
      | ">>" -> RShift
      | ">>=" -> Equal (Some RShift)
      | "=" -> Equal None
      | "==" -> EqEq
      | "&" -> Amper
      | "&=" -> Equal (Some Amper)
      | "&&" -> And
      | "^" -> Caret
      | "^=" -> Equal (Some Caret)
      | "|" -> Pipe
      | "|=" -> Equal (Some Pipe)
      | "||" -> Or
      | "?" -> QMark
      | ":" -> Colon
      | "<" -> LChevron
      | "<=" -> Leq
      | "<<" -> LShift 
      | "<<=" -> Equal (Some LShift)
      | _ -> raise NoMatch 

    let lex (fileName : string) : token list =
        let slist = split fileName in
        List.map (fun s -> matcher s) slist
end;;
